% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reglin.R
\name{reglin}
\alias{CoeffsClass}
\alias{CoeffsReg}
\alias{RsqClass}
\alias{RsqReg}
\alias{reglin}
\title{Operations of linear regression}
\usage{
RsqReg(X, y, ind.train = seq(nrow(X)))

RsqClass(X, y, ind.train = seq(nrow(X)))

CoeffsReg(X, y, ind.train = seq(nrow(X)))

CoeffsClass(X, y, ind.train = seq(nrow(X)))
}
\arguments{
\item{X}{A \link[bigmemory:big.matrix-class]{big.matrix}.
You shouldn't have missing values in your data.}

\item{y}{Either
\itemize{
\item a vector of \{-1, 1\} in the case of classification (suffix Class),
\item a vector of more than two unique values
in the case of regression (suffix Reg).
}}

\item{ind.train}{An optional vector of the row indices that are used,
for the training part.
If not specified, all data are used.}
}
\value{
\itemize{
\item \code{RsqReg} and \code{RsqClass} return a vector of
the coefficient of determination \eqn{R^2} of each regression,
\item \code{CoeffsReg} and \code{CoeffsClass} return a matrix of
the intercepts (first row) and slopes (second row) of each regression.
}
}
\description{
Operations of \bold{univariate} linear regression
(intercept, slope and coefficient of determination)
on all the columns of a \code{big.matrix}\cr
In the case of classification,
weights are used to make the results independent
from the proportion of cases / controls
(see parameter \emph{weights} of \code{lm}).
}
\examples{
# Simulating some data
N1 <- 3000
N2 <- 1000
x1 <- rnorm(N1, 0.5)
x2 <- rnorm(N2, -0.5)
x <- c(x1, x2)
x.big <- as.big.matrix(cbind(x, x+1, 2*x))

# In a case of classification
y <- c(rep(1, N1), rep(-1, N2))
res <- matrix(0, 3, ncol(x.big))
for (j in 1:ncol(x.big)) {
  mylm <- lm(y ~ x.big[, j],
             weights = c(rep(N2, N1), rep(N1, N2)))
  res[1:2, j] <- mylm$coefficients
  res[3, j] <- summary(mylm)$r.squared
}
print(res)
print(rbind(CoeffsClass(x.big, y), RsqClass(x.big, y)))

# In a case of regression
y2 <- x + rnorm(length(x), 0, 0.1)
res <- matrix(0, 3, ncol(x.big))
for (j in 1:ncol(x.big)) {
  mylm <- lm(y2 ~ x.big[, j])
  res[1:2, j] <- mylm$coefficients
  res[3, j] <- summary(mylm)$r.squared
}
print(res)
print(rbind(CoeffsReg(x.big, y2), RsqReg(x.big, y2)))

# With only half of the data
ind.train <- sort(sample(length(x), length(x) / 2))
res <- matrix(0, 3, ncol(x.big))
for (j in 1:ncol(x.big)) {
  mylm <- lm(y2[ind.train] ~ x.big[ind.train, j])
  res[1:2, j] <- mylm$coefficients
  res[3, j] <- summary(mylm)$r.squared
}
print(res)
print(rbind(CoeffsReg(x.big, y2, ind.train),
            RsqReg(x.big, y2, ind.train)))
}
\seealso{
\code{\link[bigmemory]{big.matrix-class}} \code{\link[stats]{lm}}
}

