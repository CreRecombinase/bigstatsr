% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply-parallelize.R
\name{big_apply}
\alias{big_apply}
\title{Split-Apply-Combine}
\usage{
big_apply(X.desc, a.MARGIN, a.FUN, a.combine, block.size = 1000,
  ind.row = seq_len(nrow(X.desc)), ind.col = seq_len(ncol(X.desc)), ...)
}
\arguments{
\item{X.desc}{A \link[=big.matrix.descriptor-class]{big.matrix.descriptor}.
You shouldn't have missing values in your data.}

\item{a.FUN}{The function to be applied to each subset matrix.}

\item{block.size}{Maximum number of columns read at once.
Default is \code{1000}. This parameter controls the trade-off between
memory usage and speed. Basically, the more you can load at once,
the quicker will be the execution time, at the expense of memory usage.}

\item{ind.row}{An optional vector of the row indices that are used.
If not specified, all rows are used.}

\item{ind.col}{An optional vector of the column indices that are used.
If not specified, all columns are used.}

\item{...}{Extra arguments to be passed to \code{FUN}.}
}
\value{
The result of \link{foreach}.
}
\description{
A Split-Apply-Combine strategy to apply common R functions to a \code{big.matrix}.
}
\details{
This function splits indices in parts, then apply a given function to each
subset matrix and finally combine the results.
}
\examples{
# simulate some data
N <- 50
M <- 5000
X <- big.matrix(N, M)
X[] <- rnorm(length(X))

# get the means of each column
colmeans <- big_apply(X, colMeans, .combine = 'c')
# is the shorter version of
colmeans2 <- big_apply(X, function(X, ind) {
  mat <- X[, ind, drop = FALSE]
  colMeans(mat)
}, .combine = 'c', ind.arg = TRUE)
print(all.equal(colmeans, colmeans2))

# get the norms of each column
colnorms <- big_apply(X, function(mat) sqrt(colSums(mat^2)), .combine = 'c')

# get the sums of each row
rowsums <- big_apply(X, rowSums, .combine = '+')

# get the maximum element of X (in absolute value)
maxabs <- max(big_apply(X, function(x) max(abs(x)), .combine = 'c'))

# get the crossproduct between X and a matrix A
A <- matrix(0, N, 10)
A[] <- rnorm(length(A))
XtA <- big_apply(X, function(x) crossprod(x, A), .combine = 'rbind')

# get the product between X and a matrix B
B <- matrix(0, M, 10)
B[] <- rnorm(length(B))
XB <- big_apply(X, function(x, ind, A) {
  x.part <- x[, ind, drop = FALSE]
  A.part <- A[ind, , drop = FALSE]
  x.part \%*\% A.part
}, .combine = '+', ind.arg = TRUE, A = B)
print(all.equal(XB, X[,] \%*\% B))
}
