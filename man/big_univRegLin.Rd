% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/univRegLin.R
\name{big_univRegLin}
\alias{big_univRegLin}
\title{Univariate linear regression}
\usage{
big_univRegLin(X, y, ind.train = seq(nrow(X)))
}
\arguments{
\item{X}{A \link[bigmemory:big.matrix-class]{big.matrix}.
You shouldn't have missing values in your data.}

\item{y}{Vector of responses.}

\item{ind.train}{An optional vector of the row indices that are used,
for the training part. If not specified, all data are used.}
}
\value{
A matrix with 3 rows:
\enumerate{
\item the intercepts of each regression,
\item the slopes of each regression,
\item the coefficients of determination \eqn{R^2} of each regression.
}
}
\description{
Results of \strong{univariate} linear regressions
(intercept, slope and coefficient of determination)
of each column of a \code{big.matrix}.
}
\examples{
# Simulating some data
N <- 1000
x <- rnorm(N)
x.big <- as.big.matrix(cbind(x, x+1, 2*x))

# With all data
y2 <- x + rnorm(length(x), 0, 0.5)
res <- matrix(0, 3, ncol(x.big))
for (j in 1:ncol(x.big)) {
  mylm <- lm(y2 ~ x.big[, j])
  res[1:2, j] <- mylm$coefficients
  res[3, j] <- summary(mylm)$r.squared
}
print(res)
print(big_univRegLin(x.big, y2))

# With only half of the data
ind.train <- sort(sample(length(x), length(x) / 2))
res <- matrix(0, 3, ncol(x.big))
for (j in 1:ncol(x.big)) {
  mylm <- lm(y2[ind.train] ~ x.big[ind.train, j])
  res[1:2, j] <- mylm$coefficients
  res[3, j] <- summary(mylm)$r.squared
}
print(res)
print(big_univRegLin(x.big, y2, ind.train))
}
\seealso{
\link[stats:lm]{lm}
}
