% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/univRegLog.R
\name{big_univRegLog}
\alias{big_univRegLog}
\title{Univariate logistic regression}
\usage{
big_univRegLog(X, y01, ind.train = seq(nrow(X)), covar = NULL, ncores = 1,
  backingpath = NULL, tol = 1e-08, maxiter = 20)
}
\arguments{
\item{X}{A \link[bigmemory:big.matrix-class]{big.matrix}.
You shouldn't have missing values in your data.}

\item{y01}{Vector of responses. Must be 0s and 1s.}

\item{ind.train}{An optional vector of the row indices that are used,
for the training part. If not specified, all data are used.}

\item{covar}{Matrix of covariables to be added in each model
to correct for confounders (e.g. the scores of PCA). Default
is \code{NULL} and correspond to only adding an Intercept to each model.}

\item{ncores}{Number or cores used. Default doesn't use parallelism.}

\item{backingpath}{If the matrix is filebacked, specify the directory
where the \code{big.matrix} is stored.}

\item{tol}{Relative tolerance to assess convergence of the coefficient.
Default is \code{1e-8}.}

\item{maxiter}{Maximum number of iterations before giving up.
Default is \code{20}.
Usually, convergence is reached within 3 or 4 iterations.
If there is not convergence,
\link[stats:glm]{glm} is used instead for the corresponding column.}
}
\value{
A data.frame with 4 elements:
\enumerate{
\item the slopes of each regression,
\item the standard errors of each slope,
\item the z-scores associated with each slope,
\item the p-values associated with each z-score.
}
}
\description{
Slopes of \strong{univariate} logistic regressions of each column
of a \code{big.matrix}, with some other associated statistics.
Covariates can be added to correct for confounders.
}
\examples{
# Simulating some data
data("trees")
N <- nrow(trees)
covar <- matrix(rnorm(N * 3), N)
X <- as.big.matrix(as.matrix(trees[, -1]))
y <- trees[, 1]

# without covar
lmVol0 <- summary(lm(Girth ~ Volume, data = trees))
lmHei0 <- summary(lm(Girth ~ Height, data = trees))

print(big_univRegLin(X, y))
print(rbind(lmHei0$coefficients[2, ], lmVol0$coefficients[2, ]))

# With all data
# lm
lmVol <- summary(lm(Girth ~ Volume + covar, data = trees))
lmHei <- summary(lm(Girth ~ Height + covar, data = trees))

print(big_univRegLin(X, y, covar = covar))
print(rbind(lmHei$coefficients[2, ], lmVol$coefficients[2, ]))

# With only half of the data
ind.train <- sort(sample(N, N / 2))

# lm
lmVol2 <- summary(lm(Girth ~ Volume + covar, data = trees, subset = ind.train))
lmHei2 <- summary(lm(Girth ~ Height + covar, data = trees, subset = ind.train))

print(big_univRegLin(X, y,
                     covar = covar[ind.train, ],
                     ind.train = ind.train))
print(rbind(lmHei2$coefficients[2, ], lmVol2$coefficients[2, ]))
}
\seealso{
\link[stats:glm]{glm}
}
