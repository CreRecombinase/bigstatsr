% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply-parallelize.R
\name{big_parallelize}
\alias{big_parallelize}
\title{Split-parApply-Combine}
\usage{
big_parallelize(X., p.FUN, p.combine, ncores, ind = cols_along(X.), ...)
}
\arguments{
\item{X.}{Either a \link[=big.matrix-class]{big.matrix} or
a \link[=big.matrix.descriptor-class]{big.matrix.descriptor}.}

\item{p.FUN}{The function to be applied. It must take a
\link[=big.matrix.descriptor-class]{big.matrix.descriptor} as first argument
and provide some arguments for subsetting.}

\item{p.combine}{function that is used by \link{foreach} to process the tasks
results as they generated. This can be specified as either a function or a
non-empty character string naming the function. Specifying 'c' is useful
for concatenating the results into a vector, for example. The values 'cbind'
and 'rbind' can combine vectors into a matrix. The values '+' and '*' can be
used to process numeric data. By default, the results are returned in a list.}

\item{ncores}{Number of cores used. Default doesn't use parallelism.}

\item{ind}{Initial vector of subsetting indices.}

\item{...}{Extra arguments to be passed to \code{p.FUN}.}
}
\value{
The result of \link{foreach}.
}
\description{
A Split-Apply-Combine strategy to parallelize the evaluation of a function.
}
\details{
This function splits indices in parts, then apply a given function to each
part and finally combine the results.
}
\examples{
X.desc <- big_attachExtdata()

### Computation on all the matrix
true <- big_colstats(X.desc)

big_colstats_sub <- function(X.desc, ind, cols) {
  big_colstats(X.desc, ind.col = cols[ind])
}
# 1. the computation is split along all the columns
# 2. for each part the computation is done, using `big_colstats`
# 3. the results (data.frames) are combined via `rbind`.
test <- big_parallelize(X.desc, p.FUN = big_colstats_sub,
                        p.combine = 'rbind', ncores = 2,
                        cols = cols_along(X.desc))
all.equal(test, true)

### Computation on a part of the matrix
n <- nrow(X.desc)
m <- ncol(X.desc)
rows <- sort(sample(n, n/2)) # sort to provide some locality in accesses
cols <- sort(sample(m, m/2)) # idem

true2 <- big_colstats(X.desc, ind.row = rows, ind.col = cols)

big_colstats_sub2 <- function(X.desc, ind, rows, cols) {
  big_colstats(X.desc, ind.row = rows, ind.col = cols[ind])
}
# This doesn't work because, by default, the computation is spread
# along all columns. We must explictly specify the `ind` parameter.
\dontrun{test2 <- big_parallelize(X.desc, p.FUN = big_colstats_sub2,
                                  p.combine = 'rbind', ncores = 2,
                                  rows = rows, cols = cols)}

# This now works, using `ind = seq_along(cols)`.
test2 <- big_parallelize(X.desc, p.FUN = big_colstats_sub2,
                         p.combine = 'rbind', ncores = 2,
                         ind = seq_along(cols),
                         rows = rows, cols = cols)
all.equal(test2, true2)
}
\seealso{
\link{big_apply}
}
